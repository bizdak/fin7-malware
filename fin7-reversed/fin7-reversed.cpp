// Reverse engineering of some of the payload of FIN7 malware
//
// Lloyd Macrohon <jl.macrohon@gmail.com>

#include "stdafx.h"
#include <stdint.h>
#include <Windows.h>
#include <winnt.h>
#include <winternl.h>
#include <assert.h>
#include <malloc.h>


#define _DWORD uint32_t
#define _QWORD uint64_t

#define __ROR4__(x, y) (((uint32_t)x >> y) | (uint32_t)x << (32 - y))


// stage 1: patch from shim database
// see next function (FindFunctionAddress) for reverse-engineered version of this
__int64 __fastcall sub_16C(int a1)
{
	unsigned int v1; // ebx
	int v2; // esi
	__int64 v3; // r9
	_DWORD *v4; // r10
	__int64 v5; // r11
	unsigned int *v6; // r8
	unsigned __int8 *v7; // rdx
	int v8; // edi
	unsigned __int8 v9; // cl
	__int64 result; // rax

	v1 = 0;
	v2 = a1;
	v3 = *(_QWORD *)(**(_QWORD **)(*(_QWORD *)(*(_QWORD *)(__readgsqword(0x30u) + 0x60) + 0x18i64) + 0x20i64) + 0x20i64);
	v4 = (_DWORD *)(v3 + *(unsigned int *)(*(signed int *)(v3 + 60) + v3 + 136));
	if (!v4[6])
		return 0i64;
	v5 = 0i64;
	v6 = (unsigned int *)(v3 + (unsigned int)v4[8]);
	while (1)
	{
		if (v6)
		{
			v7 = (unsigned __int8 *)(v3 + *v6);
			const char* name = (const char*)v7;
			v8 = 0;
			while (1)
			{
				v9 = *v7;
				if (!*v7)
					break;
				if ((unsigned __int8)(v9 - 'a') <= 25u)
					v9 -= ' ';
				v8 = v9 + __ROR4__(v8, 13);
				++v7;
			}
			result = v3
				+ *(unsigned int *)(v3 + (unsigned int)v4[7] + 4i64 * *(unsigned __int16 *)(v5 + (unsigned int)v4[9] + v3));
			if (v8 == v2) 
				break;
		}
		++v1;
		++v6;
		v5 += 2i64;
		if (v1 >= v4[6])
			return 0i64;
	}
	return result;
}

// reverse engineerd version of sub_16c. I've added an extra parameter to return the
// hashed function name
void* FindFunctionAddress(uint32_t hash, const char** name)
{
	struct _TEB* teb = (struct _TEB*)__readgsqword(0x30);
	struct _LIST_ENTRY* InMemoryOrderList = &teb->ProcessEnvironmentBlock->Ldr->InMemoryOrderModuleList;
	struct _LDR_DATA_TABLE_ENTRY* ldrDataEntry = (struct _LDR_DATA_TABLE_ENTRY*)((BYTE*)InMemoryOrderList->Flink->Flink - sizeof(struct _LIST_ENTRY));

	BYTE* hDllBase = (BYTE*)ldrDataEntry->DllBase;
	IMAGE_DOS_HEADER* pDos = (IMAGE_DOS_HEADER*)hDllBase;
	IMAGE_NT_HEADERS* pDllNt = (IMAGE_NT_HEADERS*)(hDllBase + pDos->e_lfanew);
	IMAGE_EXPORT_DIRECTORY* pExports = (IMAGE_EXPORT_DIRECTORY*)(hDllBase + pDllNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	if (pExports->NumberOfNames == 0)
		return NULL;

	DWORD* nameOffsets = (DWORD*)(hDllBase + pExports->AddressOfNames);
	DWORD* fnOffsets = (DWORD*)(hDllBase + pExports->AddressOfFunctions);
	WORD* nameOrdinals = (WORD*)(hDllBase + pExports->AddressOfNameOrdinals);

	void* pFuncAddr = NULL;
	for (size_t i = 0; i < pExports->NumberOfNames; i++) {
		*name = (const char*)(hDllBase + nameOffsets[i]);
		uint32_t calcHash = 0;
		for (const char* p = *name; *p; p++) {
			char ch = toupper(*p);
			calcHash = ch + __ROR4__(calcHash, 13);
		}
		pFuncAddr = hDllBase + fnOffsets[nameOrdinals[i]];
		if (calcHash == hash)
			return pFuncAddr;
	}
	return NULL;
}

// This is effectively the same as FindFunctionAddress and put in here as reference
// implementation for fin7-shellcode.asm which requires an extern GetProcAddressByHash
// As this is a lot easier to read than the assembly version
extern "C" void* __fastcall GetProcAddressByHash(uint32_t hash)
{
	struct _TEB* teb = (struct _TEB*)__readgsqword(0x30);
	struct _LIST_ENTRY* InMemoryOrderList = &teb->ProcessEnvironmentBlock->Ldr->InMemoryOrderModuleList;
	struct _LDR_DATA_TABLE_ENTRY* ldrDataEntry = (struct _LDR_DATA_TABLE_ENTRY*)((BYTE*)InMemoryOrderList->Flink->Flink - sizeof(struct _LIST_ENTRY));

	BYTE* hDllBase = (BYTE*)ldrDataEntry->DllBase;
	IMAGE_DOS_HEADER* pDos = (IMAGE_DOS_HEADER*)hDllBase;
	IMAGE_NT_HEADERS* pDllNt = (IMAGE_NT_HEADERS*)(hDllBase + pDos->e_lfanew);
	IMAGE_EXPORT_DIRECTORY* pExports = (IMAGE_EXPORT_DIRECTORY*)(hDllBase + pDllNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	if (pExports->NumberOfNames == 0)
		return NULL;

	DWORD* nameOffsets = (DWORD*)(hDllBase + pExports->AddressOfNames);
	DWORD* fnOffsets = (DWORD*)(hDllBase + pExports->AddressOfFunctions);
	WORD* nameOrdinals = (WORD*)(hDllBase + pExports->AddressOfNameOrdinals);

	void* pFuncAddr = NULL;
	for (size_t i = 0; i < pExports->NumberOfNames; i++) {
		const char* name = (const char*)(hDllBase + nameOffsets[i]);
		uint32_t calcHash = 0;
		for (const char* p = name; *p; p++) {
			char ch = toupper(*p);
			calcHash = ch + __ROR4__(calcHash, 13);
		}
		pFuncAddr = hDllBase + fnOffsets[nameOrdinals[i]];
		if (calcHash == hash)
			return pFuncAddr;
	}
	return NULL;
}


int DumpStage1FunctionHashes()
{
	uint32_t hashes[] = { 0x50df3b21, 0xed686dc1, 0xb67242fd, 0x5947fd91, 0x50df3b21, 0x69a0287f, 0x9bd4442f, 0 };

	printf("Stage1 function hashes from shim database payload\n");
	printf("%-10s  |  %-40s  |  %s\n", "Hash", "Function Name", "Address");
	printf("----------------------------------------------------------------------------\n");
	for (int i = 0; hashes[i]; i++) {
		const char* name = NULL;
		const void* addr = FindFunctionAddress(hashes[i], &name);
		printf("0x%08x  |  %-40s  |  %p\n", hashes[i], name, addr);
	}
	printf("\n\n");

	// these hashes are:
	//Stage1 function hashes from shim database payload
	//	Hash | Function Name | Address
	//	----------------------------------------------------------------------------
	//	0x50df3b21 | NtQueryValueKey | 00007FFC50535670
	//	0xed686dc1 | NtOpenKey | 00007FFC505355D0
	//	0xb67242fd | RtlInitUnicodeString | 00007FFC504A1620
	//	0x5947fd91 | NtAllocateVirtualMemory | 00007FFC50535690
	//	0x50df3b21 | NtQueryValueKey | 00007FFC50535670
	//	0x69a0287f | NtFreeVirtualMemory | 00007FFC50535750
	//	0x9bd4442f | NtClose | 00007FFC50535570

	return 0;
}

int main()
{
	DumpStage1FunctionHashes();
    return 0;
}

